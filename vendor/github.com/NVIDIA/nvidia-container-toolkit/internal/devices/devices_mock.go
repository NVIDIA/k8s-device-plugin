// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package devices

import (
	"sync"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
//	func TestSomethingThatUsesInterface(t *testing.T) {
//
//		// make and configure a mocked Interface
//		mockedInterface := &InterfaceMock{
//			AssertCharDeviceFunc: func(s string) error {
//				panic("mock out the AssertCharDevice method")
//			},
//			DeviceFromPathFunc: func(s1 string, s2 string) (*Device, error) {
//				panic("mock out the DeviceFromPath method")
//			},
//		}
//
//		// use mockedInterface in code that requires Interface
//		// and then make assertions.
//
//	}
type InterfaceMock struct {
	// AssertCharDeviceFunc mocks the AssertCharDevice method.
	AssertCharDeviceFunc func(s string) error

	// DeviceFromPathFunc mocks the DeviceFromPath method.
	DeviceFromPathFunc func(s1 string, s2 string) (*Device, error)

	// calls tracks calls to the methods.
	calls struct {
		// AssertCharDevice holds details about calls to the AssertCharDevice method.
		AssertCharDevice []struct {
			// S is the s argument value.
			S string
		}
		// DeviceFromPath holds details about calls to the DeviceFromPath method.
		DeviceFromPath []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
	}
	lockAssertCharDevice sync.RWMutex
	lockDeviceFromPath   sync.RWMutex
}

// AssertCharDevice calls AssertCharDeviceFunc.
func (mock *InterfaceMock) AssertCharDevice(s string) error {
	if mock.AssertCharDeviceFunc == nil {
		panic("InterfaceMock.AssertCharDeviceFunc: method is nil but Interface.AssertCharDevice was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockAssertCharDevice.Lock()
	mock.calls.AssertCharDevice = append(mock.calls.AssertCharDevice, callInfo)
	mock.lockAssertCharDevice.Unlock()
	return mock.AssertCharDeviceFunc(s)
}

// AssertCharDeviceCalls gets all the calls that were made to AssertCharDevice.
// Check the length with:
//
//	len(mockedInterface.AssertCharDeviceCalls())
func (mock *InterfaceMock) AssertCharDeviceCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockAssertCharDevice.RLock()
	calls = mock.calls.AssertCharDevice
	mock.lockAssertCharDevice.RUnlock()
	return calls
}

// DeviceFromPath calls DeviceFromPathFunc.
func (mock *InterfaceMock) DeviceFromPath(s1 string, s2 string) (*Device, error) {
	if mock.DeviceFromPathFunc == nil {
		panic("InterfaceMock.DeviceFromPathFunc: method is nil but Interface.DeviceFromPath was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockDeviceFromPath.Lock()
	mock.calls.DeviceFromPath = append(mock.calls.DeviceFromPath, callInfo)
	mock.lockDeviceFromPath.Unlock()
	return mock.DeviceFromPathFunc(s1, s2)
}

// DeviceFromPathCalls gets all the calls that were made to DeviceFromPath.
// Check the length with:
//
//	len(mockedInterface.DeviceFromPathCalls())
func (mock *InterfaceMock) DeviceFromPathCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockDeviceFromPath.RLock()
	calls = mock.calls.DeviceFromPath
	mock.lockDeviceFromPath.RUnlock()
	return calls
}
